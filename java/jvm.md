## JVM组成
![](https://i.loli.net/2021/04/19/V6JRjZ2Wliw8PDr.png)
  - 类加载器: 将class字节码文件加载到运行时数据区域中
  - 执行引擎: 执行classes中的指令
  - Native Interface: 底层语言(C++)交互的接口
## JMM(Java内存模型)
### JMM组成
![](https://i.loli.net/2021/04/19/NUe9AZrvWClRcQi.png)
  - 程序计数器: 当前线程执行的指令指示器, 用来标记线程执行的指令的位置, 线程独占.
  - Java虚拟机栈: 以栈帧的形式存储局部变量表、操作数栈、动态链接、方法出口等信息, 每个方法的调用则会产生一个栈帧. 线程独占.
  - 堆(Heap): Java虚拟机中最大的内存区域, 对象实例化时在堆上分配内存. 此区域时线程共享的.
  - 方法区(Method Area): 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码, 常量池也在此区域.
### 类创建机制
1. 类加载. 检查new指令的参数能够在常量池中定位到这个类的符号引用, 并检查这个引用符号代表的类是被加载, 解析和初始化过. 若没有则进行相应的类加载过程.
2. 分配内存. 根据类加载机制确定的对象所需内存空间大小在Java Heap中分配内存. 内存分配方式包括"指针碰撞"和"空闲列表"两种方式.
    - 指针碰撞: 若Java Heap的内存规整, 则将空闲与使用内存分界点的指针向空闲区移动需要分配的内存大小.
    - 空闲列表: 若Java Heap的内存不规整, 则需要由JVM维护一个空闲内存列表记录可使用内存区域, 分配内存时需要找查表找到足够大的内存区域分配所需内存, 分配后修改空闲列表.

**类创建的并发问题:**
由于频繁对象, 内存区域的状态修改也是频繁的, 此过程会出现线程不安全的问题.解决方案主要有两种:

  - 对分配内存空间的动作进行同步处理
  - 将内存分配的动作按照线程划分在不同的空间中, 即对每个线程在Java堆中预分配一小块内存, 即`Thread Local Allocation Buffer`. 当线程初始化对象时, 直接用自己的TLAB区域中分配内存.
### 对象的内存布局
HotSpot虚拟机中, 对象在堆内存中的存储分为三个部分:Header, Instance, Padding
  - Header
    Header包含两类信息:
    - 存储对象自身的运行时数据(64位), 包括HashCode, GC分代年龄, 锁状态标志, 线程持有的锁, 偏向线程ID, 偏向时间戳
    - 类型指针: 指向对象类型元数据的指针
  - Instance Data: 对象中的字段等数字.
  - Padding: HotSpot内存管理系统要求对象的起始地址必须是8字节的整数倍, 意味着任何对象的内存大小都必须是8字节的整数倍, Padding用于内存对齐.
### 对象的访问定位
对象的访问定位有两种方式:直接访问和句柄访问.
  - 直接指针访问: 引用中直接存储对象地址, 然后再通过实例的Header中的类型指针访问对象的类型数据. **优点是速度快, 节省一次指针定位时间开销**.
    ![](https://i.loli.net/2021/04/19/1o9e7ilGDstzwkB.png)
  - 句柄访问: 间接访问的手段, Java Heap中划分中特定的句柄池, 每个句柄用来存储对象的地址和对象类型数据地址. **优点是在对象被移动时, 不用修改引用的值, 只需要修改句柄**.
    ![](https://i.loli.net/2021/04/19/58QrATIxboi2HGy.png)
## GC(垃圾回收机制)
Java不需要程序显示地释放过期对象地内存空间, 有JVM的GC机制自动地执行. 在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收.
### JVM的内存回收机制的原理
GC在程序运行的全程在监视对象的状态, JVM使用有向图的方式管理对象, 通过可达性分析以确定哪些对象需要进行内存回收. 不可达的对象不在有引用, 也即是不可达对象.
`System.gc()` 会通知GC运行一次垃圾回收.
### Java的引用类型
  - 强引用: 不会被回收.
  - 软引用: 有用但不是必须的对象, 在发生内存溢出之前被回收. 使用SoftReference修饰.
  - 弱引用: 有用但不是必须的对象, 在下一次GC发生时被回收. 使用WeakReference修饰.
  - 虚引用: 无法通过虚引用获得对象.
### GC算法
基础的内存回收算法:
  - Mark-Sweep(标记清除算法): 标记无用对象, 然后进行回收清除.
    **优点**: 实现简单, 不移动对象.
    **缺点**: 效率低, 容易产生内存碎片, 垃圾回收频率高.
  - 标记复制算法: 将内存空间划分为两个相等空间, 每次使用一个区域. 当前区域垃圾回收时, 将不回收的对象复制到另一个区域的连续空间, 对当前区域所有空间回收. 
    **优点**: 不会产生内存碎片, 运行效率高.
    **缺点**: 内存使用空间减半, 复制次数频繁.
  - Mark-Cmpact (标记-整理算法): 老年代对象存活率高, 复制算法效率较低, 且内存容量减半. Mark-Compact算法在Mark-Sweep算法的基础上, 将存活对象移动到内存区域的一端, 以消除内存碎片.

JVM采用分代收集的内存回收算法. 即根据对象不同时期的特点, 将内存进行划分, 不同的内存区域采用不用的垃圾回收机制. JVM一般将对象分为年轻代, 老年代和永久代三种.
    ![](https://i.loli.net/2021/04/19/Ht3hKCni6ozrD1M.png)
不同内存区域的内存回收算法不同:
    ![](https://i.loli.net/2021/04/19/D4VxQyLBuKr16at.png)

  - Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效.
  - ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现.
  - Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景.
  - Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
  - Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本.
  - CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间.
    - 初始标记：单线程，标记GC root的直接关联对象， 阻塞线程
    - 并发标记：并发进行 GC trace过程，不阻塞线程
    - 重标记：重新标记并发标记过程中因程序继续运行而发生标记改变的标记，阻塞线程
    - 并发清除：不阻塞线程
  - G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。

### 分代
#### 新生代
新生代默认占总空间的1/3, 使用标记复制算法, 有较高的效率. 新生代区域包含三个分区: Eden, S0, S1, 三个区域的大小比为8:1:1. 新对象总在Eden区中分配内存. 发生垃圾回收机制时, 将Eden区和一个S区中的存活对象复制到另外的S区, 对当前Eden区和S区完全回收. 下次回收时, 存活对象复制到上次回收的S区, 即两个S区交替使用.

> 这里注意, 新生代的机制是建立在新对象普遍生命周期短的情况下, 如果存活的对象超过S区的大小, 则需要依赖其他的内存区域进行分配担保, 即直接进入老年代. 
### 老年代
新生代对象每次在S区之间复制时, 年龄增加1, 当年龄达到默认配置15时, 则会升级为老年代, 进入老年代对应的内存区域. 大对象直接进入老年代.
老年代内存区域占这个空间大小的2/3, 当其内存占用达到某个阈值时, 则会触发一次全局的垃圾回收, 一般使用标记整理算法.

